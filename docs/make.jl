using RxInferServer
using Documenter
using DocumenterMermaid
using HTTP, Dates

DocMeta.setdocmeta!(RxInferServer, :DocTestSetup, :(using RxInferServer); recursive = true)

# Check if the server is running by pinging it with timeout
function wait_for_server(;
    host = "localhost", port = RxInferServer.RXINFER_SERVER_PORT(), timeout_seconds = 600, retry_interval = 5
)
    @info "Waiting for server to start before building documentation..."
    endpoint = "http://$(host):$(port)/v1/ping"
    start_time = now()
    server_started = false

    while (now() - start_time) < Second(timeout_seconds)
        try
            response = HTTP.get(endpoint, status_exception = false)
            if response.status == 200
                @info "Server started successfully! Proceeding with documentation build."
                server_started = true
                break
            end
        catch e
            # This is expected if the server isn't ready yet
            @info "Server not ready yet, retrying in $(retry_interval) seconds..."
        end
        sleep(retry_interval)
    end

    if !server_started
        error("Server failed to start within the timeout period ($(timeout_seconds)s). Cannot build documentation.")
    end

    return server_started
end

# Verify that the server is running before proceeding with documentation build
wait_for_server()

function snake_case(camelstring; joinwith = "_")
    wordpat = r"
    ^[a-z]+ |                  #match initial lower case part
    [A-Z][a-z]+ |              #match Words Like This
    \d*([A-Z](?=[A-Z]|$))+ |   #match ABBREV 30MW 
    \d+                        #match 1234 (numbers without units)
    "x

    smartlower(word) = any(islowercase, word) ? lowercase(word) : word
    words = [smartlower(m.match) for m in eachmatch(wordpat, camelstring)]

    join(words, joinwith)
end

"""
    get_operation_ids()

Extracts all operationIds from the OpenAPI spec.yaml file and returns them as an array.
"""
function get_operation_ids()
    # Path to the spec.yaml file
    spec_path = joinpath(@__DIR__, "..", "openapi", "spec.yaml")

    # Read the file content
    content = read(spec_path, String)

    # Regular expression to find operationId fields
    operation_id_pattern = r"operationId:\s*([a-zA-Z0-9]+)"

    # Find all matches
    matches = collect(eachmatch(operation_id_pattern, content))

    # Extract the operationId values
    operation_ids = [match.captures[1] for match in matches]

    # Prepare docfixes for the URLs and the operation IDs
    docfixes_url = Any[string("md#", id) => string("md#**", snake_case(id), "**") for id in operation_ids]
    docfixes_ops = Any[id => snake_case(id; joinwith = "\\_") for id in operation_ids]

    docfixes = vcat(docfixes_url, docfixes_ops)

    # I don't know why these are being auto-generated but they do not exist
    push!(docfixes, "[**Map**](AnyType.md)" => "**Map**")
    push!(docfixes, "[**List**](map.md)" => "**List**")

    # Add rule for HTML anchor tags
    push!(docfixes, r"<a\s+name=\"([^\"]+)\"></a>" => s"```@raw html\n<a name=\"\1\"></a>\n```")

    return operation_ids, docfixes
end

# Get Operation IDs
operation_ids, docfixes = get_operation_ids()

@info "Detected OpenAPI operation IDs:\n" * join(["  â€¢ " * snake_case(id) for id in operation_ids], "\n")

"""
    copy_openapi_docs(subdirectory = "server")

Copies the autogenerated OpenAPI documentation from openapi/server/docs to docs/src/openapi
and returns a list of pages to be added to the documentation.
The subdirectory can either be "server" or "client".
"""
function copy_openapi_docs(; subdirectory = "server")
    # Create the destination directory if it doesn't exist
    openapi_docs_dir = joinpath(@__DIR__, "src", "openapi")
    mkpath(openapi_docs_dir)

    # Path to the OpenAPI generated docs
    openapi_source_dir = joinpath(@__DIR__, "..", "openapi", subdirectory, "docs")

    # Banner to add at the top of each file
    autogen_banner = """
    !!! info "Auto-generated content"
        This page is automatically generated from the OpenAPI specification.

    """

    # Function to recursively find all markdown files
    function find_markdown_files(dir)
        files = []
        for entry in readdir(dir; join = true)
            if isfile(entry) && endswith(entry, ".md")
                push!(files, relpath(entry, openapi_source_dir))
            elseif isdir(entry) && !endswith(entry, ".openapi-generator")
                append!(files, find_markdown_files(entry))
            end
        end
        return files
    end

    # Get a list of all markdown files in the OpenAPI docs recursively
    openapi_files = find_markdown_files(openapi_source_dir)

    # Copy README.md file as well
    readme_source = joinpath(@__DIR__, "..", "openapi", subdirectory, "README.md")
    readme_dest = joinpath(openapi_docs_dir, "README.md")
    if isfile(readme_source)
        readme_content = read(readme_source, String)

        # Apply docfixes
        readme_content = replace(readme_content, docfixes...)

        # Add the auto-generated banner
        readme_content = autogen_banner * readme_content * autogen_banner

        # Write the modified README content
        write(readme_dest, readme_content)
    end

    # Copy each file, fix relative paths, and collect the page entries for the docs
    openapi_pages = []

    for file in openapi_files
        source_path = joinpath(openapi_source_dir, file)
        dest_path = joinpath(openapi_docs_dir, file)

        # Create the destination directory if it doesn't exist
        mkpath(dirname(dest_path))

        # Read the file content
        content = read(source_path, String)

        # Fix the relative links to other docs (e.g., docs/ServerInfo.md -> ServerInfo.md)
        content = replace(content, r"docs/([A-Za-z0-9_]+\.md)" => s"\1", docfixes...)

        # Add the auto-generated banner
        content = autogen_banner * content * autogen_banner

        # Write the modified content to the destination file
        write(dest_path, content)

        # Create nested structure for pages
        parts = splitpath(file)
        page_name = replace(last(parts), ".md" => "")

        # Create the page entry preserving the folder structure
        if length(parts) == 1
            # Root level files
            push!(openapi_pages, page_name => joinpath("openapi", file))
        else
            # Nested files - create a nested structure
            section_name = first(parts)
            if !any(p -> p[1] == section_name, openapi_pages)
                # Add a new section if it doesn't exist
                section_pages = [page_name => joinpath("openapi", file)]
                push!(openapi_pages, section_name => section_pages)
            else
                # Add to existing section
                section_idx = findfirst(p -> p[1] == section_name, openapi_pages)
                if section_idx !== nothing
                    push!(openapi_pages[section_idx][2], page_name => joinpath("openapi", file))
                end
            end
        end
    end

    # Add README to the pages at the beginning
    if isfile(readme_dest)
        pushfirst!(openapi_pages, "Overview" => joinpath("openapi", "README.md"))
    end

    # Remove the original README.md from openapi_pages
    deleteat!(openapi_pages, findfirst(p -> p[1] == "README", openapi_pages))

    return openapi_pages
end

"""
    copy_openapi_spec()

Copies the openapi/spec.yaml file to docs/src/openapi/spec.yaml and returns the path to the file.
"""
function copy_openapi_spec()
    # Create the destination directory if it doesn't exist
    openapi_spec_dir = joinpath(@__DIR__, "src", "openapi")
    mkpath(openapi_spec_dir)

    # Copy the spec.yaml file
    spec_source = joinpath(@__DIR__, "..", "openapi", "spec.yaml")
    spec_dest = joinpath(openapi_spec_dir, "spec.yaml")
    cp(spec_source, spec_dest; force = true)

    return spec_dest
end

# Get OpenAPI documentation pages
openapi_server_pages = copy_openapi_docs(subdirectory = "server")
openapi_client_pages = copy_openapi_docs(subdirectory = "client")
openapi_spec = copy_openapi_spec()

is_draft = get(ENV, "DOCS_DRAFT", "false") == "true"

makedocs(;
    modules = [RxInferServer],
    warnonly = is_draft,
    authors = "Lazy Dynamics <info@lazydynamics.com>",
    sitename = "RxInferServer",
    format = Documenter.HTML(;
        prettyurls = get(ENV, "CI", nothing) == "true",
        canonical = "https://server.rxinfer.com",
        edit_link = "main",
        assets = [],
        analytics = "G-TCF3D8BVYF",
        description = "A RESTful HTTP server implementation for RxInfer.jl, a reactive message passing inference engine for probabilistic models.",
        footer = "Created and sponsored by [LazyDynamics](https://lazydynamics.com/), powered by [Documenter.jl](https://github.com/JuliaDocs/Documenter.jl) and the [Julia Programming Language](https://julialang.org/). Licensed under [AGPL-3.0](http://github.com/lazydynamics/RxInferServer?tab=readme-ov-file#license)."
    ),
    pages = [
        "Home" => "index.md",
        "Getting started" => "getting-started.md",
        "API design" => [
            "Authentication" => "api/authentication.md",
            "Model management" => "api/model-management.md",
            "Learning parameters of a model" => "api/learning.md",
            "Status codes and error handling" => "api/status-codes.md",
            "Server details and version" => "api/server-info.md",
            "Request preferences" => "api/request-preferences.md"
        ],
        "Configuration" => "configuration.md",
        "Manuals" => [
            "How to add a model" => "manuals/how-to-add-a-model.md",
            "Inference vs Learning" => "manuals/inference-vs-learning.md",
            "Continual learning" => "manuals/continual-learning.md"
        ],
        "Server components" => [
            "Models" => "components/models.md",
            "Database" => "components/database.md",
            "Logging" => "components/logging.md",
            "Serialization" => "components/serialization.md"
        ],
        "Developers guide" => "developers-guide.md",
        "OpenAPI documentation" =>
            ["Overview" => "openapi.md", "Server" => openapi_server_pages, "Client" => openapi_client_pages]
    ]
)

deploydocs(;
    repo = "github.com/lazydynamics/RxInferServer.jl",
    devbranch = "main",
    forcepush = true,
    cname = "server.rxinfer.com"
)
